---
title: "Tarea 1"
author: "Pablo,Sofía,Román"
date: "26/1/2020"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

#raffle 
date <- 26012020
set.seed(date)
pablo <- sample(1:4,size = 1)
sofia <- sample(1:4,size = 1)
roman <- sample(1:4,size = 1)

#libraries 
library(datasets)
library(GGally)
library(dplyr)
library(gridExtra)
library(knitr)
library(ggplot2)
library(lattice)
library(ggplot2)
library(tidyverse)
library(corrplot)
```

# Ejercicio 2
## 2a
```{r}
columns<-c("x1",
           "x2",
           "x3",
           "x4",
           "x5",
           "x6")
```

```{r}
data <- read.delim("T01_06.txt", header = FALSE, sep= "", col.names = columns)
```

```{r}
data$x6<-as.factor(data$x6)
```


```{r}
#Scatterplot X2 y X4 para multiescleriosis (x6=1)
ggplot(subset(data, x6==1), aes(y=x2, x= x4, color=x6))+ xlab("la respuesta total de ambos ojos a estimulos S2")+ylab("la respuesta total de ambos ojos a estimulos S1") +geom_jitter(alpha=0.3)+theme_minimal()

#Parace que existe una tendencia lineal creciente con respesto a la respuesta de ambos ojos a cada uno de los estímulos. Existen casos atípicos en los que las respuestas fueron "extremas".
```
## 2b

```{r}
#Convertimos el data frame en matriz
data.matrix(data, rownames.force = NA)
```

```{r}
#Resultados media para el grupo sin MS (x6=0)
x_barra_0<-apply(subset(data2, data$x6==0),2,mean)
```

```{r}
#Resultados media para el grupo con MS (x6=1)
x_barra_0<-apply(subset(data2, data$x6==1),2,mean)
```

```{r}
S<-var(data2) #Matriz de varianazas y covarianzas
#cov(data2) Matriz de varianazas y covarianzas
R<-cor(data2) #Matriz de correlaciones
```

## 2c


```{r}
#Scratterplot x1 y x2
ggplot(data, aes(x=x1, y= x2, color=x6))+ xlab("edad")+ylab("la respuesta total de ambos ojos a estimulos S1") +geom_jitter(alpha=0.3)+theme_minimal()
#Parece que existe una tendencia lineal creciente entre la edad y la respuesta de los ojos al primer estímulo si las personas no tienen SM; sin embargo, para las personas que padecen dicha enfermedad no tienen una respuesta a la prueba relacionada con su edad.
```

```{r}
#Scratterplot x1 y x3
ggplot(data, aes(x=x1, y= x3, color=x6))+ xlab("edad")+ylab("la diferencia entre respuestas de los ojos a estímulos S1") +geom_jitter(alpha=0.3)+theme_minimal()

#El cambio en la diferencia entre respuesta de los ojos ante el estímulo S1 es casi nula al cambiar la ededad para embos grupos. Hay más variabilidad para el grupo con SM que para el resto. Las personas con SM parece que no tienen cambio alguno con el aumento de edad.
```

```{r}
#Scratterplot x1 y x4
ggplot(data, aes(x=x1, y= x4, color=x6))+ xlab("edad")+ylab("la respuesta total de ambos ojos a estimulos S2") +geom_jitter(alpha=0.3)+theme_minimal()

#El segundo estímulo no tiene una tendencia clara para ninguno de los grupos y los grupos no se comportan de manera similar. Para los estudiados "enfermos" parece haber mucha más variabilidad.
```

```{r}
#Scratterplot x1 y x5
ggplot(data, aes(x=x1, y= x5, color=x6))+ xlab("edad")+ylab("la diferencia entre respuestas de los ojos a estímulos S2") +geom_jitter(alpha=0.3)+theme_minimal()
 
#Al igual que en la gráfica anterior, se puede apreciar que las personas con escleriosis tienen un comportamiento muy distintos a sus contrapartes. Mientras las personas sin SM tienen cambios menos notorios en la diferencia de respuesta ante el S2 on respecto a la edad, los enfermos sí presentan variabilidad. Cada grupo sigue la tendencia presente entre la edad y la diferencia ante el estímulo S1.
```

```{r}
#Scratterplot x2 y x3
ggplot(data, aes(x=x2, y= x3, color=x6))+ xlab("la respuesta total de ambos ojos a estimulos S1")+ylab("la diferencia entre respuestas de los ojos a estímulos S1") +geom_jitter(alpha=0.3)+theme_minimal()

#Las observaciones para las personas sin SM parecen tener una tendencia lineal con pendiente cero; es decir, no cambiar con la respuesta al estímulo S1. Para el grupo con SM no hay tendencias claras.
```

```{r}
#Scratterplot x2 y x4
ggplot(data, aes(x=x2, y= x4, color=x6))+ xlab("la respuesta total de ambos ojos a estimulos S1")+ylab("la respuesta total de ambos ojos a estimulos S2") +geom_jitter(alpha=0.3)+theme_minimal()

#Se presenta, como esperado, una tendencia creciente entre las respueestas de ambos ojos ante los estímulos S1 y S2. Entre mejor respuesta con un estímulo, mayor será con el otro.
```

```{r}
#Scratterplot x2 y x5
ggplot(data, aes(x=x2, y= x5, color=x6))+ xlab("la respuesta total de ambos ojos a estimulos S1")+ylab("lla diferencia entre respuestas de los ojos a estímulos S2") +geom_jitter(alpha=0.3)+theme_minimal()

#No hay tendencias a simple vista y no se esperaría que existiera una empíricamente.
```

```{r}
#Scratterplot x3 y x4
ggplot(data, aes(x=x3, y= x4, color=x6))+ xlab("la diferencia entre respuestas de los ojos a estímulos S1")+ylab("la respuesta total de ambos ojos a estimulos S2") +geom_jitter(alpha=0.3)+theme_minimal()

#Ocurre lo mismo que apra x2 y x3, con los ejes rotados.
```

```{r}
#Scratterplot x3 y x5
ggplot(data, aes(x=x3, y= x5, color=x6))+ xlab("la diferencia entre respuestas de los ojos a estímulos S1")+ylab("la diferencia entre respuestas de los ojos a estímulos S2") +geom_jitter(alpha=0.3)+theme_minimal()
#Claramente hay más variabilidad para el grupo de los pacientes con SM que con el resto, pero als tendencias no son claras.
```

```{r}
#Scratterplot x4 y x5
ggplot(data, aes(x=x4, y= x5, color=x6))+ xlab("la respuesta total de ambos ojos a estimulos S2")+ylab("la diferencia entre respuestas de los ojos a estímulos S2") +geom_jitter(alpha=0.3)+theme_minimal()

#No se espera que haya una tendencia para estos datos y no ocurre cómo tal.

#Ejercicio 1

```{r}
  A <- matrix(c(7,5,3,2,1,8),ncol = 3)
  B <- matrix(c(11,-7,8,12,0,9),ncol = 3)
  #a) A'
    t(A)
  #b) A − B
    A - B
  #c) AB  
    A*B
  #d) A'A
    t(A)%*%A
  #e) AA'
    A%*%t(A)
  #f) A + B
    A + B
  #g) A'B
    t(A)%*%B
  #h) AB'
    A%*%t(B)
  #i) 17.3*A
    17.3*A
  #j) (1/19)*B
    (1/19)*B

```

# Ejercicio 3
## Las flores de Fisher y Anderson

### 3a

Se presenta a continuación la matrix de covarianza muestral insesgada $\textbf{S}_{X}$, de los datos para la Iris Setosa. 

```{r}
X <- iris3[,,1] #1 is for Setosa
s_mn <- apply(X = X,MARGIN = 2,FUN = mean)

#corrected mean square 
dim_set <- dim(X)[1]
s_mn_matrix <- matrix(rep(s_mn,each = dim_set), nrow = dim_set)
A <- X - s_mn_matrix
A <- t(A) %*% A

#unbaised sample covarianse
Sx <- (1/(dim_set -1) * A)

kable(A,"markdown")
```



### 3b

Los eigenvalores y eigenvectores de  $\textbf{S}_{X}$ son:

```{r}
#eigenpar 
eigen_list <- eigen(Sx)
kable(eigen_list$values, col.names = "Eigenvalores")

```

```{r}
kable(eigen_list$vectors, "markdown", col.names = c("v1","v2","v3","v4"), label = "Eigenvectores")
```


### 3c

Mostraremos que: 

- $ULU^{T} = S_{X}$

- $U^{T}U = UU^{T} = I_{4 \times 4}$

Checamos entrada por entrada si el error relativo $\varepsilon = \frac{\left\| A - \tilde{A}|\right|_{\infty}}{ \left\|\tilde{A}|\right|_{\infty}}$es menor a cierta tolerancia. Fijemos la tolerancia numérica de $\text{tol} = e^{-8}$ para la norma del supremo de la matriz a comparar. 
```{r}
U <- eigen_list$vectors
L <- diag(eigen_list$values)

#compute Sx = ULU'
Sx_prim = U %*% L %*% t(U)
testSx <- norm(Sx_prim - Sx,"I") / norm(Sx,"I")

```

Observamos que el error relativo $\varepsilon_{1} =$ $`r testSx`$ es menor que la tolerancia, por tanto se cumple la igualdad numéricamente.


```{r}
#compute UU' & U'U 
UUt <- U %*% t(U)
UtU <- t(U) %*% U

test_uut <- norm(UUt - diag(1,nrow = 4),"I") / norm(UUt,"I")
test_utu <- norm(UtU - diag(1,nrow = 4),"I") / norm(UtU,"I")

```

También podemos ver que el error relativo $\varepsilon_{2} =$ $`r test_uut`$ y el error relativo $\varepsilon_{2} =$ $`r test_utu`$  es menor que la tolerancia, por tanto se cumple la igualdad numéricamente para ambos casos.

### 3d

Se mostrará un cuatro gráficas de dispersión. Una para cada categoría de Iris y la última es una gráfica conjunta. Esto con el mootivo de estudiar por separado y con mayor legibilidad las gráficas por cada tipo y la última con el fin de comparar la distribución para cada especie de flor.

```{r}
matplot_setosa <- iris %>% 
                  filter(Species == "setosa") %>%  
                  select(Sepal.Length, Sepal.Width, Petal.Length) %>%
                  ggpairs() +
                  theme_bw() +
                  labs(title = "SETOSA", x = "", y = "") +
                  theme(plot.margin = margin(1,.3,1,.3,"cm"))

matplot_veris <- iris %>% 
                  filter(Species == "versicolor") %>%  
                  select(Sepal.Length, Sepal.Width, Petal.Length) %>%
                  ggpairs() + 
                  theme_bw() +
                  labs(title = "VERSICOLOR", x = "", y = "") +
                  theme(plot.margin = margin(1,.3,1,.3,"cm"))

matplot_virg <- iris %>% 
                  filter(Species == "virginica") %>%  
                  select(Sepal.Length, Sepal.Width, Petal.Length) %>%
                  ggpairs() +
                  theme_bw() +
                  labs(title = "VIRGINICA", x = "", y = "") +
                  theme(plot.margin = margin(1,.3,1,.3,"cm"))
          


matplot_all <- iris %>% 
                  ggscatmat(color = 'Species') + 
                  theme_bw() + 
                  labs(title = "FLORES", x = "", y = "", color = "Especie de\n flor") +
                  theme(plot.margin = margin(1.1,.35,1.1,.35,"cm"))

#we omitted this graph because it looked very heaped
# matplot_all2 <- iris %>% 
#                   ggpairs(mapping = aes(color = 'Species')) + 
#                   theme_light() + 
#                   labs(title = "Figura 1", x = "", y = "", color = "Especie de\n flor")


matplot_setosa
matplot_veris
matplot_virg
matplot_all

```

Se observa que hay una relación lineal positiva entre el largo y ancho del petalo, como el largo y el ancho del sépalo. Hay correlaciones positivas para estos casos, donde las corelaciones muestrales mayores se presentan en la especie virgínica.


# Ejercicio 4
## Flores de Fisher y Anderson parte II.

### 4a

Sabemos que $Y^{5} = X^{3} + X^{4}.$ Entonces, para encontar $C$ tal que 
$$ Y = XC,$$
se puede notar que $C$ debe ser de la forma
```{r}
# \[
# C=
# \left[
# \begin{array}{c|c}
# I_{4,4} & 
# 
# \begin{array}{c}
# 0 \\ 0 \\ 1 \\ 1\end{array}
# 
# 
# \end{array}
# \right]
# \]
```



```{r}
Y <- cbind(X,(X[,'Petal L.'] + X[,'Petal W.']))
colnames(Y) <- c('Sepal L.','Sepal W.','Petal L.', 'Petal W.', 'PL + PW')

#C
C <-  diag(x = 1, nrow = 4)
C <-  cbind(C,c(0,0,1,1))

#check if Y = XC
testY <- norm(Y - X %*% C,"I")/norm(X %*% C,"I")


```


Es de notar que el error relativo $\varepsilon_{4} =$ $`r testY`$ es menor que la tolerancia, por tanto $Y = XC$, numéricamente.


### 4b

La matriz de covarianzas corregidas esta dada por

```{r}
# X <- iris3[,,1] #1 is for Setosa
# s_mn <- apply(X = X,MARGIN = 2,FUN = mean)
# #corrected mean square 
# dim_set <- dim(X)[1]
# s_mn_matrix <- matrix(rep(s_mn,each = dim_set), nrow = dim_set)
# A <- X - s_mn_matrix
# # for(i in 1:4){
# #   A[,i] <- A[,i] * A[,i]
# # }
# A <- t(A) %*% A
# #unbaised sample covarianse
# Sx <- (1/(dim_set -1) * A)
# 
# kable(A,"markdown")

#covariance matrix of Y

#mean of columns and dim
s_mnY <- apply(X = Y, MARGIN = 2, FUN = mean)
dim_Y <- dim(Y)[1]
s_mn_matrixY <- matrix(rep(s_mnY,each = dim_Y), nrow = dim_Y)


#corrected mean squear 
B <- Y - s_mn_matrixY
Sy <- (1/(dim_Y -1)) * t(B) %*% B

kable(Sy)
```
.

Los eigenpares de la matriz $S_{Y}$ están dados por

```{r}
#eigenpair
eigen_listY <- eigen(Sy)

kable(eigen_listY$values, col.names = "Eigenvalores")
```


```{r}
kable(eigen_listY$vectors, "markdown", col.names = c("v1","v2","v3","v4","v5"), label = "Eigenvectores")

```

### 4c

Igualmente mostraremos numéricamente que $S_{Y} = C^{T}S_{X}C$ con la norma del supremo.
```{r}
#compare relative error
tol <- exp(-8)
testSy <- (norm(t(C) %*% Sx %*% C - Sy, "I")) / (norm(t(C) %*% Sx %*% C,"I"))


```

Es de notar que el error relativo $\varepsilon_{5} =$ $`r testSy`$ es menor que la tolerancia, entonces se cumple la igualdad.


# Ejercicio 5
## EDA de los Indicadores de la CNBV

La CNBV publica indicadores financieros de manera mensual con el objetivo de de proporcionar estadísticas descriptivas para reflejar la evolución de la condición financiera de la Banca Múltiple.
```{r}
doc1 <- "DatosCNBVModificados1.csv"
doc2 <- "DatosCNBVModificados2.csv"

data_cnbv1 <- read.csv(file = doc1)
data_cnbv2 <- read.csv(file = doc2)
```


### Tipo de variables

### Preguntas de investigación
- Observar si existe una diferencia en el promedio del _monto_ y _flujo por mes_ en los distintos periodos.

- Observar si existe una diferencia en el promedio del _monto_ y _flujo por mes_ en la Banca Múltiple.

- ¿Existirá una tendencia en la distribución del _monto_ y _flujo por mes_ en la Banca Múltiple?

- ¿Existe alguna relación entre  _monto_ y _flujo por mes_?

- ¿Hubo cambios en el orden de  _montos_ y _flujos por mes_ en la Banca Múltiple?

## Patrones relevantes
```{r}

ruta <- "Datos.csv"
datos1 <- read.csv(ruta, header = T, nrows = 2269, encoding="UTF-8")
datos2 <- read.csv(ruta, header = T, skip = 2270, encoding="UTF-8")
```

```{r}
#Inciso a)
clase_1 <- lapply(datos1, class)
str(datos1)
```

```{r}
#Inciso b)
#       1) ¿Cuál es el monto promedio del mes?
datos1$Monto <- as.numeric(as.character(datos1$Monto))
monto_mean<-mean(datos1$Monto,na.rm = TRUE)
monto_mean
#       2)¿Cuál es el concepto que más se repite?
datos1$Monto<-as.numeric(as.character(datos1$Monto))
datos1$Flujo_Mes<-as.numeric(as.character(datos1$Flujo_Mes))
getmode <- function(v) {
   uniqv <- unique(v)
   uniqv[which.max(tabulate(match(v, uniqv)))]
}

#En el primer data frame:
concepto_1<-getmode(datos1$Concepto)
#En el segundo data frame:
concepto_2<- getmode(datos2$Concepto)

concepto_1 #las modas son iguales para los dos DF

#       3)¿Existe una relación entre el monto y el flujo del mes?
correlacion<-cor(datos1$Monto,datos1$Flujo_Mes)
correlacion

```

¿Hay valores nulos o faltantes?  
```{r}
datos1[datos1=="?"]<-NA
summary(datos1)
```

```{r}
datos2[datos2=="?"]<-NA
summary(datos2)
```

```{r}
data <- datos1 %>%  
          select(-c(X.U.FEFF.cve_item,Textbox3,Flujo_Mes)) %>%
          filter(cve_periodo == "201804") %>%
          spread(Concepto, Monto) %>%
          select(-cve_periodo)
names(data) <- c("inst", "dep_pubgen","mdo_din","dep_plazo","dep_exi","tit_cred")
bancos <- data$inst
data <- as.data.frame(apply(data[,-1], 2,
                             function(x) as.numeric(gsub(pattern = ",",
                                                         replacement = "", x, fixed = TRUE))))
row.names(data) <-bancos #separamos por cada Banco
View(data)

data <- data[,-3] # porque presenta colinealidad
head(data)
```

```{r}
sapply(datos1,class)
x<-c("cve_periodo","Monto","Flujo_Mes")
datos1[,x]<-lapply(datos1[,x], as.factor)
summary(datos1)
```

```{r}
datos1$Monto <- as.numeric(as.character(datos1$Monto))
datos1$Flujo_Mes <- as.numeric(as.character(datos1$Flujo_Mes))
ggscatmat(datos1, columns = 6:7, color = "Concepto", alpha = 0.5, corMethod = "pearson")
```

```{r}
ggplot(datos1, aes(cve_periodo, Monto)) + geom_boxplot() + ylab("")
```


```{r}
g_lm <- ggplot(datos1, mapping = aes(x = Monto, y = Flujo_Mes)) +
          geom_point(mapping = aes(col = cve_periodo)) +
          geom_smooth(method = "lm") +
          theme_bw() +
          labs(title = "Regresión General", x = "", y = "Flujo Mes") 
g_sm <- ggplot(datos1, mapping = aes(x = Monto, y = Flujo_Mes, col = cve_periodo )) +
          geom_point() +
          geom_smooth() +
          theme_bw() +
          labs(title = "Regresión por periodo", x = "Monto", y = "Flujo Mes") 
grid.arrange(g_lm,
             g_sm,
             ncol = 1)

# union of the two data to see duplicated data
colnames(data_cnbv2) <- colnames(data_cnbv1)
data_cnbv <- rbind(data_cnbv1,data_cnbv2)
data_cnbv$Monto[data_cnbv$Monto == ""] <- NaN
data_cnbv$Flujo_Mes[data_cnbv$Flujo_Mes == ""] <- NaN

#duplicated data
dupl_data <- duplicated(data_cnbv,incomparables = FALSE)
dup_count <- sum(as.numeric(dupl_data)) 

data_cnbv <- data_cnbv[-which(dupl_data),]

#number of NA's 
na_data <- is.na(data_cnbv$Monto) | is.na(data_cnbv$Flujo_Mes)
na_count <- sum(as.numeric(na_data)) 
data_cnbv <- data_cnbv[-which(na_data),]

#cast factor variables to numeric variables
data_cnbv$cve_periodo <- as.factor(data_cnbv$cve_periodo)
data_cnbv$Monto <- as.numeric(data_cnbv$Monto)
data_cnbv$Flujo_Mes <- as.numeric(data_cnbv$Flujo_Mes)

```

## Resumen de todas las variables
```{r}
# general summary
summary(data_cnbv)

```

## Flujo por mes & monto.
```{r}
#matrix plot
mat_plt_all <- data_cnbv %>% 
              ggscatmat(color = 'cve_periodo') +
              theme_bw() +
              labs(title = "Datos CNBV", x = "", y = "", color = "Periodo") +
              theme(plot.margin = margin(1.1,.35,1.1,.35,"cm"))

mat_plt_all

#boxplot
gbox_cnbv <- ggplot(data_cnbv, mapping = aes(x = cve_periodo, y = Monto, fill = cve_periodo)) + geom_boxplot() 

gbox_cnbv

```

# Tendencia entre Flujo del mes y el monto.

```{r}

g_lm <- ggplot(data_cnbv, mapping = aes(x = Monto, y = Flujo_Mes)) +
          geom_point(mapping = aes(col = cve_periodo)) +
          geom_smooth(method = "lm") +
          theme_bw() +
          labs(title = "Regresión General", x = "", y = "Flujo Mes") 

g_sm <- ggplot(data_cnbv, mapping = aes(x = Monto, y = Flujo_Mes, col = cve_periodo )) +
          geom_point() +
          geom_smooth() +
          theme_bw() +
          labs(title = "Regresión por periodo", x = "Monto", y = "Flujo Mes") 

grid.arrange(g_lm,
             g_sm,
             ncol = 1)



ruta <- "DatosCNBVIndicadores.csv"
datos1 <- read.csv(ruta,header = T, nrows = 2269, encoding="UTF-8")
datos2 <- read.csv(ruta, header = T, skip = 2270, encoding="UTF-8") 

#Inciso a)
clase <- lapply(datos2, class)
str(datos2)
head(datos2)


#Inciso b)
#       1) 
#       2)
#       3)

```

Se observa que existe una relación lineal entre el monto y el flujo por mes, sin embargo, las categorías no muestran esa relación lineal y fluctua dependiendo del nivel del monto.


### Reportar aberraciones en los datos

Primero que nada, se enfatiza que los datos en el archivo .csv publicado por la CNBV contiene  `r dup_count` datos reptidos, de igual manera contiene `r na_count`  datos faltantes, por lo que se optó por eliminar dichos datos. De igual manera (distribuciones)


Es de observar que 

```{r}
datos <- datos2 %>%  
          select(-c(Textbox4,cve_item2,Flujo_Mes1)) %>%
          filter(cve_periodo2 == "201805") %>%
          spread(Concepto1, item_Importe2) %>%
          select(-cve_periodo2)

names(datos) <- c("inst", "dep_pubgen","mdo_din","dep_plazo","dep_exi","tit_cred")
bancos <- datos$inst
datos <- as.data.frame(apply(datos[,-1], 2, 
                             function(x) as.numeric(gsub(pattern = ",", 
                                                         replacement = "", x, fixed = TRUE))))
row.names(datos) <-bancos #por conveniencia separamos los nombres de los bancos de los datos.
View(datos)
datos <- datos[,-3] # porque presenta colinealidad
head(datos)

```
```{r}
l <- c(grep("Consolidado",bancos),grep("G-7",bancos),grep("Servicios",bancos),
       grep("Comercial",bancos),grep("Total Banca",bancos),grep("Créditos a los Hogares",bancos),
       grep("Bicentenario",bancos),grep("Deuno",bancos),grep("Wal-Mart",bancos),
       grep("ING",bancos),grep("Ixe",bancos),grep("Wal-Mart",bancos),grep("GE Money",bancos),
       grep("New York Mellon",bancos), grep("UBS",bancos))
BD <- datos[-l,]
BD
summary(BD)
BD <- log(BD + 1)
```


```{r}
summary(BD)
par(mfrow=c(2,2))
for(i in 1:4){
  hist(BD[,i], xlab = colnames(BD)[i], ylab = "frecuencia", main = "", breaks = 20)
}
```

```{r}
pairs(BD)
n <- dim(BD)[1]
xbar <-apply(BD,2,mean,na.rm=T)
xbar
S <- var(BD, na.rm = T)
S
R <- cor(BD,use="pairwise")
R
corrplot.mixed(corr = R, upper = "ellipse")
```
```{r}
radio <- sqrt(BD$dep_exi/ pi ) #escalado a área correcta de acuerdo a los depósitos de exigibilidad
with(BD, symbols(dep_pubgen,mdo_din,circles=radio, inches = 0.25, fg="white", bg="red"))
with(BD, points(dep_pubgen, mdo_din, type = "p", cex = 0.3))
with(BD, text(dep_pubgen, mdo_din, row.names(bancos), cex=0.5, offset = 0.01, adj = 0.05))
```

```{r}
stars(BD,key.loc=c(-0.7,17))
```

